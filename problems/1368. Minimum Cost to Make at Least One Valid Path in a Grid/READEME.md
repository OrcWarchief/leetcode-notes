# LeetCode 1368 ? Minimum Cost to Make at Least One Valid Path in a Grid

> **한 줄 요약(TL;DR)**
> 격자의 각 칸에서 주어진 방향으로 가면 비용 0, 그 외로 가면 간판(방향)을 바꾸는 비용 1이 든다.
> (0,0) → (m?1,n?1) 최소 비용은 **0?1 BFS**(덱) 또는 **다익스트라**로 구한다.
> 간선 가중치는 **항상 0 또는 1**.

---

## 1) 문제 요약

* `grid[r][c] ∈ {1,2,3,4}` 는 현재 칸의 “추천 방향”을 의미.

  * 1: 오른쪽(→), 2: 왼쪽(←), 3: 아래(↓), 4: 위(↑)
* 현재 칸에서 **추천 방향으로 이동하면 비용 0**, 다른 방향으로 이동하면 **비용 1**(간판 바꾸기).
* 시작: (0,0), 목표: (m?1,n?1).
* 최소 총 비용 반환.

---

## 2) 핵심 아이디어 ? 그래프 모델링

* 칸 `(r,c)` 를 정점으로 보고, 인접 4칸으로의 간선을 만든다.
* 간선 가중치:

  * 만약 이동 방향이 `grid[r][c]`와 같으면 가중치 0, 아니면 1.
* 이렇게 만들면 **모든 간선 가중치가 0 또는 1**이므로 **0?1 BFS**가 최적.

---

## 3) 0?1 BFS 절차(덱 사용)

1. `dist[r][c] = ∞` 로 초기화; `dist[0][0] = 0`.
2. 덱 `dq` 에 `(0,0)` 삽입.
3. 덱이 빌 때까지 반복:

   * 앞에서 꺼낸다: `(r,c)`
   * 4방향 `(nr,nc)` 에 대해:

     * `w = (방향이 grid[r][c]와 같으면 0, 아니면 1)`
     * `newDist = dist[r][c] + w`
     * `newDist < dist[nr][nc]` 이면 갱신: `dist[nr][nc] = newDist`

       * `w == 0` → **덱 앞**에 push (가까운 노드 우선)
       * `w == 1` → **덱 뒤**에 push
4. 반환: `dist[m-1][n-1]`.

### 왜 0?1 BFS인가?

* **가중치가 0 또는 1**이면, 다익스트라의 우선순위 큐 대신 **덱**으로도 최단거리를 보장할 수 있다.
* 0 가중치는 큐의 앞에, 1 가중치는 뒤에 넣어 **가중치 순서를 자연스럽게 유지**한다.

---

## 4) 다익스트라(대안)

* 일반적인 최단거리 알고리즘.
* 우선순위 큐 사용; 구현은 보편적이나 **0?1 BFS보다 느리고 코드가 길 수 있음**.
* 그래도 `O(E log V)` 로 충분히 통과.

---

## 5) 직관/증명 스케치

* 간판을 바꾸는 행위는 **그 칸에서 한 번**만 고려되며, 경로 상에서 각 간선의 비용(0/1)을 독립적으로 합산하면 전체 비용.
* 따라서 **가중치 비음수** 조건을 만족하는 전형적인 단일 원천 최단거리 문제.
* 0?1 가중치는 **덱을 통한 레벨형 확장**으로 최단성을 유지한다.

---

## 6) 복잡도

* 격자 크기 `m×n` = `V`, 간선은 각 정점당 최대 4개 → `E ? 4V`.
* **0?1 BFS**: `O(V + E)` ? `O(mn)`.
* **다익스트라**: `O(E log V)` ? `O(mn log(mn))`.

---

## 7) 구현 체크리스트

* 경계 체크: `(nr, nc)` 가 격자 범위 내인지 확인.
* 방문/완화 조건: `newDist < dist[nr][nc]` 일 때만 덱 삽입.
* 방향 매핑:

  * `dirs = [(0,1),(0,-1),(1,0),(-1,0)]` 를 1\~4에 매핑 (인덱스 오프바이원 주의).
  * 예: `dirIndex = grid[r][c] - 1` 가 추천 방향의 인덱스.
* 초기화: `dist`는 큰 값으로, 시작점 0.
* 조기 종료(옵션): `(m-1,n-1)` 거리 갱신 시 바로 리턴해도 됨(0?1 BFS는 가능한데, 보통은 끝까지 돌려도 무방).

---

## 8) 자주 하는 실수

* **방향 인덱스 혼동**: (→,←,↓,↑) 순서/번호를 틀리면 전체 결과가 어긋남.
* **0 간선의 처리**를 덱 **뒤**에 넣는 실수: 반드시 **앞**에 넣어야 함.
* `dist` 갱신 없이 중복 삽입: 비효율. 반드시 `newDist < dist` 일 때만 삽입.
* 시작점도 “간판 교체”가 가능한가? 가능하지만 **추천 방향과 다른 방향으로 나가면 그 간선에 1이 붙는 것**일 뿐, 별도 예외 없음.

---

## 9) 테스트 케이스 아이디어

1. 최소 크기: `1×1` → 답 0.
2. 일직선에 모두 올바른 화살표 → 답 0.
3. 모든 칸 방향이 전부 반대 → 직선 경로라도 매 칸마다 1 비용씩.
4. 우회가 더 싸게 보이는 경우 vs 직진하며 조금 바꾸는 경우 비교.
5. 큰 격자에서 **0?1 BFS 성능** 확인(최악: `100×100` 이상).

---

## 10) 변형/확장 관점

* **가중치가 0/1이 아닌 일반 양수**: 0?1 BFS 불가 → 다익스트라로 일반화.
* **방향 수가 더 많거나(예: 8방향)**: 매핑만 늘리면 동일 로직.
* **장애물/불가 이동 칸**: 해당 간선 제거.

---

## 11) 요약 메모

* 그래프 변환: 칸→정점, 4방향→간선(0/1 가중치)
* 핵심 알고리즘: **0?1 BFS (덱)**
* 정답: `dist[m-1][n-1]`

> 기억 포인트: **“추천 방향 = 0, 아니면 1”** 그리고 \*\*“덱 앞/뒤”\*\*만 틀리지 말자.
