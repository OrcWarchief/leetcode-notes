LeetCode 2045 ? Second Minimum Time to Reach Destination

요약: 무가중치 양방향 그래프에서 1번 노드에서 n번 노드까지 도달하는 두 번째로 빠른 도착 시간을 구한다. 간선 이동에는 고정 시간 time이 들고, 모든 노드의 신호등이 동기화되어 change 간격으로 초록/빨강이 번갈아가며 바뀐다. 출발은 초록일 때만 가능하며, 빨강이면 다음 초록이 올 때까지 대기한다. 시간 0은 초록으로 시작한다.

문제 핵심

그래프: 1..n 노드, 무가중치, 양방향.

간선 이동 시간: 모든 간선 동일하게 time.

신호등: 각 노드에서 출발 시에만 제약.

구간 [0, change) 초록 → [change, 2*change) 빨강 → [2*change, 3*change) 초록 → …

시각 t에서 출발 가능 여부는 ((t // change) % 2 == 0)인지로 판정 (참이면 초록).

빨강이면 t를 다음 초록 시각으로 이월: t = (t // change + 1) * change.

목표: 노드 n에 도달하는 두 번째로 작은(서로 다른) 도착 시각.

직관 & 정리

출발 제약은 “노드에서 떠날 때만” 적용된다. 도착 시에는 제약 없음(도착 후 즉시 떠나려면 그때의 신호를 본다).

이동 횟수(간선 수)가 k일 때, “가능한 한 빨리 출발” 전략을 따르면 도착 시각은 경로 모양과 무관하고 k만으로 결정된다.
→ 따라서 “시간”을 직접 다익스트라로 최적화하든, “간선 수의 두 번째 최단(> 첫 번째)”를 찾아서 해당 k로 시뮬레이션하든 둘 다 성립한다.

구현은 다음 2가지가 대표적:

우선순위 큐(시간 기준) + 각 노드 2회 도착만 수용

**BFS로 각 노드까지의 1·2번째 최단 ‘간선 수’**를 구한 뒤, k2에 대해 신호등 대기 포함 시뮬레이션

풀이 A ? “시간” 기반(추천: 직관적이고 견고)

아이디어: (시간, 노드)를 우선순위 큐로 팝하며 각 노드에 대해 서로 다른 도착 시각을 최대 2개까지만 저장한다.
n이 두 번째로 팝되는 순간의 시간이 답.

알고리즘

인접 리스트 구성.

pq = [(0, 1)] (시각 0에 1번 노드).

arr_times[u]에 노드 u의 서로 다른 도착 시각을 기록(최대 2개).

팝한 (t, u)에 대해:

u에 t로 처음이거나 두 번째 도착이면 수용.

만약 u == n이고 n에 대한 두 번째 도착이면 t 반환.

이 시각 t에서 u를 떠나려면, 빨강이면 대기:

if (t // change) % 2 == 1: t = (t // change + 1) * change

nt = t + time로 모든 이웃 (v)에 푸시(단, v에 대한 기록이 2개 미만일 때만).

시간/공간 복잡도

각 노드는 최대 2번만 확정 도착 → 푸시 상한 O(2m)

우선순위 큐 연산 포함: O(m log n)

공간: O(n + m)
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {
        vector<vector<int>> g(n + 1);
        for (auto &e : edges) {
            g[e[0]].push_back(e[1]);
            g[e[1]].push_back(e[0]);
        }

        using P = pair<long long,int>;
        priority_queue<P, vector<P>, greater<P>> pq;
        pq.push({0, 1});

        vector<vector<long long>> arrived(n + 1); // up to two distinct arrival times per node

        while (!pq.empty()) {
            auto [t, u] = pq.top(); pq.pop();

            if (!arrived[u].empty() && arrived[u].back() == t) continue;

            arrived[u].push_back(t);
            if ((int)arrived[u].size() > 2) continue;

            if (u == n && (int)arrived[u].size() == 2) return (int)t;

            long long depart = t;
            if ((depart / change) % 2 == 1) {
                depart = (depart / change + 1) * 1LL * change;
            }
            long long nt = depart + time;

            for (int v : g[u]) {
                if ((int)arrived[v].size() < 2) {
                    pq.push({nt, v});
                }
            }
        }
        return -1;
    }
};

풀이 B ? “간선 수” 기반(BFS) + 시뮬레이션

아이디어: 무가중치 그래프이므로 BFS로 각 노드까지의 최단 간선 수와 그보다 큰 두 번째 간선 수를 구한다. 목표 노드 n의 두 번째 간선 수를 k2라 하면, k2회 이동을 순서대로 시뮬레이션하여 도착 시간을 얻는다.

핵심 포인트

각 노드 v에 대해 dist1[v](최단 간선 수), dist2[v](그보다 큰 두 번째 간선 수)를 유지.

큐에는 (u, d)를 넣어 d+1로 이웃을 갱신:

d+1 < dist1[v] → 갱신 및 푸시

dist1[v] < d+1 < dist2[v] → 두 번째 갱신 및 푸시
(중요: dist2는 엄밀히 더 큰 간선 수만 수용 → dist2[n] == dist1[n] 되는 일 없음)

마지막에 k2 = dist2[n].
시뮬레이션: k2번 반복하면서, 매 단계 출발 전에 빨강이면 대기, 그리고 time만큼 이동.
올바름(정당화) 스케치

신호 제약은 ‘출발 시각’만 의존하며, 경로의 구체적 형태와는 무관하다. 따라서 어떤 고정된 간선 수 k에 대해 “가능한 한 빨리 출발” 규칙을 적용하면 유일한 도착 시각이 정해진다.

풀이 A: 전역적으로 시간 증가 순으로 상태를 탐색하고, 각 노드의 서로 다른 상위 2개의 도착 시각만 수용하므로, n의 두 번째 도착이 전역 최소의 두 번째 값임이 보장된다.

풀이 B: 무가중치 그래프에서 dist2[v]는 dist1[v]보다 엄격히 큰 두 번째 간선 수를 의미한다. k2 = dist2[n]에 대해 시뮬레이션한 시간은 가능한 경로들 중 두 번째로 작은 도착 시각에 대응한다(같은 k라면 동일 시간).

구현 팁 & 함정 체크리스트

? 경계 시각: t가 change의 배수일 때는 막 빨강으로 바뀐 시점이므로 출발 불가.
⇒ 빨강 판정: if (t // change) % 2 == 1.

? 도착과 출발 분리: 도착 자체에는 제약 없음. 떠날 때만 신호 확인.

? 중복 시간 제거: 동일 노드 동일 시각 중복 처리 시 한 번만 수용.

? 두 번째는 “서로 다른” 시간: 첫 도착 시각과 동일하면 두 번째로 치지 않음.

? 오버플로 주의(C++): 중간 계산은 long long 사용.

? 복잡도 보장: 각 노드 최대 2회 도착만 확정 → 상태 수 유한.
언제 어떤 풀이를 쓸까?

풀이 A(시간 기반): 가장 직관적이고 실전에서 안전. 코드 길이는 조금 더 짧고, 반례에 강함.

풀이 B(간선 수 기반): 무가중치 특성을 적극 활용. 신호 시뮬레이션을 분리해 깔끔하게 사고 가능.

템플릿 주석(면접/복습용)

핵심 한 줄: “각 노드별 ‘서로 다른’ 도착 시각 상위 2개만 보면 된다.”

빨강 대기 공식:
if (t // change) % 2 == 1: t = (t // change + 1) * change

경로 길이 k에 대한 도착 시각은 경로 형태와 무관(항상 가능한 한 빨리 출발한다고 가정).

복잡도 목표: O(m log n) 또는 O(n + m).

확장 아이디어

“세 번째 최소 시간” 일반화: 각 노드에서 상위 K개의 도착 시각을 저장하면 그대로 확장 가능(상태 수 K·n).

에지마다 시간이 다를 때: 풀이 A에서 출발 대기만 동일하게 처리하고, 간선 가중치만 반영하면 됨.