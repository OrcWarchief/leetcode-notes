# README ? LeetCode?56.?Merge?Intervals

## 개요
**Merge?Intervals** 문제는 정렬되지 않은 구간(interval) 목록이 주어졌을 때,  
겹치는 구간을 모두 병합하여 서로 겹치지 않는 **최소 구간 집합**을 반환하는 고전적인 배열·정렬 문제입니다.  
입력 크기가 최대 수만 개까지 주어질 수 있으므로 `O(N?log?N)` 정렬 + `O(N)` 선형 스캔 알고리즘을 구현해야 통과할 수 있습니다.

---

## 문제 설명
> 정수 쌍?`intervals[i] = [start_i, end_i]`?가 담긴 2차원 배열 `intervals` 가 주어집니다.  
> 각 `intervals[i]` 는 **닫힌 구간**(start?≤?end)을 나타냅니다.  
> **서로 겹치는 모든 구간**을 합쳐서 겹치지 않는 구간들의 목록을 반환하세요.

### 예시?1
```text
입력 : [[1,3],[2,6],[8,10],[15,18]]
출력 : [[1,6],[8,10],[15,18]]
```

### 예시?2
```text
입력 : [[1,4],[4,5]]
출력 : [[1,5]]
```

---

## 제약 조건

| 항목 | 값 |
|------|----|
| 구간 개수 `n` | 1?≤?n?≤?10⁴ (플랫폼마다 10⁴~10?) |
| 각 구간 값 | ?10??≤?start_i?≤?end_i?≤?10? |

---

## 알고리즘

1. **정렬**?? 시작점을 기준으로 오름차순 정렬  
   정렬 복잡도?`O(N?log?N)`  
2. **선형 스캔 & 병합**  
   * 결과 벡터 `res` 에 첫 구간을 넣는다.  
   * 두 번째 구간부터 차례로 순회하면서  
     * `current.start`?≤?`res.back().end`?이면 **겹침** → `res.back().end = max(res.back().end, current.end)`  
     * 아니면 **겹치지 않음** → `res.push_back(current)`  
   * 스캔 복잡도?`O(N)`  
3. **반환**?? 병합이 완료된 `res` 반환

### 시간·공간 복잡도

| 단계 | 시간 | 공간 |
|------|------|------|
| 정렬 | `O(N?log?N)` | `O(1)`*(in?place sort)* |
| 스캔 | `O(N)` | `O(N)`*(최악: 전혀 안 겹칠 때)* |
| **총합** | **`O(N?log?N)`** | **`O(N)`** |

---

## 구현 (C++17)

```cpp
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        if (intervals.empty()) return {};               // 예외 처리

        // 1) 시작점 기준 정렬
        sort(intervals.begin(), intervals.end(),
             [](const vector<int>& a, const vector<int>& b) { return a[0] < b[0]; });

        // 2) 결과 벡터
        vector<vector<int>> res;
        res.push_back(intervals[0]);

        // 3) 선형 스캔
        for (size_t i = 1; i < intervals.size(); ++i) {
            if (intervals[i][0] <= res.back()[1]) {     // 겹침
                res.back()[1] = max(res.back()[1], intervals[i][1]);
            } else {                                    // 겹치지 않음
                res.push_back(intervals[i]);
            }
        }
        return res;
    }
};
```

> **왜 `size_t`?**  
> * `vector::size()` 와 동일한 타입(부호 없는 정수)로 비교?경고를 방지한다.  
> * 64?bit 환경에서 더 큰 인덱스 범위를 안전하게 다룰 수 있다.

---

## 핵심 포인트 요약
* **정렬 → 선형 스캔** 패턴은 간단하면서도 최적의 복잡도를 제공한다.  
* 병합 기준은 “다음 구간의 시작?≤?현재 구간의 끝” 한 가지만 체크하면 충분하다.  
* 벡터 원소를 수정할 때는 **참조(`&`)** 또는 `res.back()`에 직접 접근해야 원본이 갱신된다.  
* 역방향 루프를 작성할 때는 `size_t` 언더플로에 주의한다.

---

## 테스트 케이스 모음

```text
1. [[1,3],[2,6],[8,10],[15,18]]          → [[1,6],[8,10],[15,18]]
2. [[1,4],[4,5]]                         → [[1,5]]
3. [[1,4],[5,6]]                         → [[1,4],[5,6]]
4. [[1,4]]                               → [[1,4]]
5. []                                     → []
6. [[2,2],[1,3]]                         → [[1,3]]
7. [[-10,-1],[-5,0],[1,2]]               → [[-10,0],[1,2]]
8. [[1,10],[2,3],[4,8],[9,12]]           → [[1,12]]
```

---

## 확장 아이디어

| 주제 | 설명 |
|------|------|
| 구간의 **열린/닫힌** 여부 | `[start, end)` 형태라면 `<=`?→?`<` 로 조건만 바꾸면 된다. |
| **실수 구간** | 끝값 비교만 가능하면 동일 로직으로 동작한다. |
| **대규모 데이터** | 외부 정렬 후 한 번 스트리밍 스캔으로 확장 가능하다. |
| **이벤트 캘린더** 등 삽입·삭제 반복 | `std::map`/`std::set` 또는 인터벌 트리로 O(log?N) 삽입·삭제 + 주변 병합. |

---