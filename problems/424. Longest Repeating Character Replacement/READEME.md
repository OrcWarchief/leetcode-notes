424. Longest Repeating Character Replacement (C++)

1. 문제 요약
주어진 문자열 s(대문자로만 구성)에서 최대 k번의 문자 교체(임의의 위치의 문자를 원하는 다른 문자로 변경 가능)를 사용하여
모든 문자가 동일한 가장 긴 부분 문자열의 길이를 구한다.

입력	제한	출력
문자열 s, 정수 k	1 ≤ s.length ≤ 10?, 0 ≤ k ≤ s.length	조건을 만족하는 부분 문자열의 최대 길이

예시

ini
복사
s = "AABABBA", k = 1 → 4  // "AABA" 또는 "ABBA"
2. 핵심 아이디어???슬라이딩 윈도우
윈도우 정의

양 끝 인덱스 [l, r](포함)로 현재 후보 부분 문자열을 표시한다.

빈도 테이블 유지

cnt[26] 배열: 윈도우 안 각 문자 빈도.

maxFreq: 윈도우 내 가장 많이 등장한 문자의 빈도(빈도 테이블에서 최대값).

윈도우 유효성

윈도우 크기 = r - l + 1

바꾸어야 할 문자 수 = 윈도우 크기 - maxFreq

조건: 윈도우 크기 - maxFreq ≤ k 이면 교체 가능 → 윈도우 확장

조건을 위배하면 l을 증가시켜 윈도우 축소

결과 갱신

매 단계에서 유효한 윈도우 크기로 ans 갱신.

복잡도

시간?O(n) (각 문자를 윈도우에 한 번씩만 추가/제거)

공간?O(1) (26?길이 테이블)

? 관찰: 교체 횟수를 줄이려면 가능한 한 가장 많이 등장한 문자에 나머지를 맞추면 된다.
maxFreq는 윈도우 축소 시 과대평가될 수 있으나, 조건이 위배될 때만 축소하므로 정답에는 영향이 없다.

3. 구현 (C++17)
cpp
복사
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int characterReplacement(string s, int k) {
        int cnt[26] = {0};
        int l = 0, maxFreq = 0, ans = 0;

        for (int r = 0; r < s.size(); ++r) {
            int idx = s[r] - 'A';
            maxFreq = max(maxFreq, ++cnt[idx]);

            while ((r - l + 1) - maxFreq > k) {   // 유효성 검사
                --cnt[s[l] - 'A'];
                ++l;
            }
            ans = max(ans, r - l + 1);             // 길이 갱신
        }
        return ans;
    }
};
주요 라인 해설
라인	설명
maxFreq = max(maxFreq, ++cnt[idx]);	새 문자 포함 후 현재 윈도우 최대 빈도 갱신
while ((r - l + 1) - maxFreq > k)	교체 필요 문자가 k 초과 → 왼쪽 포인터 이동
ans = max(ans, r - l + 1);	조건을 만족하는 가장 긴 길이 추적

4. 자주 하는 실수 & 디버깅 팁
maxFreq 재계산

윈도우 축소 시 maxFreq를 즉시 감소시키지 않아도 안전하다.

단, 빈도 배열에서 감소 후 다음 번 max() 호출 시 정확해지므로 조건식이 보수적이어야 한다.

while vs if

한 번의 축소로 조건을 만족한다는 보장이 없으므로 while 루프 사용.

k==0 경계

교체 불가이므로 단순 최장 동일 문자 구간 로직과 동일하게 동작해야 한다.

5. 복잡도 분석
시간	공간
최적 해법	O(n)	O(1)

6. 확장·변형 아이디어
소문자/다국어 처리?: 알파벳 수가 달라져도 원리는 동일, 빈도 테이블 크기만 조정.

최소 교체 횟수?: 길이를 고정한 뒤 k 최소값을 구하려면 k = len - maxFreq 로 즉시 계산 가능.

여러 문자열 일괄 처리?: O(Σn) 으로 독립 실행.

7. 결론
슬라이딩 윈도우에 “윈도우 크기 - 최빈도 ≤ k” 라는 단순하지만 강력한 불변식을 적용하면
O(n) 시간·O(1) 공간으로 문제를 해결할 수 있다.