# LeetCode 1976 ? Number of Ways to Arrive at Destination

> **한 줄 요약(TL;DR)**
> 가중치가 있는 무방향 그래프에서 **0 → n?1 최단거리**를 구하고,
> **해당 최단거리로 도착하는 경로의 수**를 DP로 함께 계산한다.
> 알고리즘: **다익스트라 + 경로 개수 세기**.

---

## 1) 문제 요약

* `n`개의 노드(0 \~ n?1), 주어진 도로(양방향, 각 가중치 ≥ 1).
* 시작: 0, 목표: n?1.
* 조건: **최단 거리**로 도착하는 서로 다른 경로의 개수를 `1e9+7`로 나눈 나머지를 반환.

---

## 2) 핵심 아이디어

* 다익스트라로 최단거리 배열 `dist[]`를 계산.
* 동시에 `ways[]` 배열 유지:

  * `ways[u]` = 노드 `u`에 **최단거리로 도착하는 경로의 수**.
* 시작 조건: `ways[0] = 1`.

업데이트 규칙:

* 어떤 간선 `u ?w?> v`를 확인할 때:

  * **새로운 더 짧은 거리 발견**: `dist[v] > dist[u] + w`

    * `dist[v] = dist[u] + w`
    * `ways[v] = ways[u]`
  * **동일한 최단거리 발견**: `dist[v] == dist[u] + w`

    * `ways[v] = (ways[v] + ways[u]) % MOD`

---

## 3) 절차 (다익스트라 변형)

1. `dist[]` = ∞, `ways[] = 0` 초기화.
2. `dist[0] = 0, ways[0] = 1`.
3. 우선순위 큐에 `(0, 0)` 삽입 (거리, 노드).
4. 큐에서 노드 `u`를 꺼낼 때:

   * `dist[u]`가 현재 거리보다 작으면 skip.
   * 모든 인접 `(v, w)` 확인 후 위 규칙으로 `dist[v], ways[v]` 갱신.
5. 마지막에 `ways[n?1]` 출력.

---

## 4) 직관/증명 스케치

* 다익스트라는 항상 **최단거리 확정 순서**로 노드를 방문한다.
* `ways[v]`는 오직 `dist[u] + w`가 `dist[v]`와 일치할 때만 누적되므로, **모든 최단경로 조합**을 정확히 세게 된다.
* 새로운 더 짧은 거리가 발견되면, 기존 `ways[v]`는 무효화되고 `ways[u]`로 덮어씌운다. 이는 “최단거리 정의 갱신”과 일관된다.

---

## 5) 복잡도

* `E` = 간선 수, `V` = 노드 수.
* 다익스트라: `O(E log V)`.
* `ways` 갱신은 간선 Relax 단계에 상수 연산만 추가되므로 동일.

---

## 6) 구현 체크리스트

* MOD = 1e9+7.
* `long long`/`int64`로 거리 합산 처리 (가중치 최대치에 대비).
* 그래프는 **무방향**이므로 간선 양쪽으로 추가.
* 동일 간선이 여러 번 나올 수 있음 → 모두 반영.
* 시작/도착이 동일(`n=1`)일 경우 ways=1.

---

## 7) 자주 하는 실수

* `dist[v] == dist[u] + w`일 때 `ways[v] += ways[u]` 누락.
* MOD 처리 누락 → 오버플로.
* `dist[u]`보다 긴 경로를 큐에서 꺼냈을 때 불필요하게 다시 확장.
* 가중치 합을 `int`로 두어 오버플로 발생.

---

## 8) 테스트 케이스 아이디어

1. **단일 경로**: 선형 그래프 → ways=1.
2. **다중 최단경로**: 삼각형(0-1,0-2,1-2)에서 0→2 최단경로가 2개.
3. **더 긴 경로 무시**: 다양한 경로 있지만 최단 아닌 건 배제.
4. **큰 그래프**: 성능 확인.
5. **동일 거리 중복 간선**: 경로 수 정확히 합산되는지 확인.

---

## 9) 요약 메모

* 알고리즘 = **다익스트라 + 경로 개수 DP**.
* 업데이트 규칙 = 더 짧으면 덮어쓰기, 같으면 누적.
* 답 = `ways[n?1] % MOD`.

> 기억 포인트: **최단거리 갱신과 경로수 갱신을 정확히 분리**.
